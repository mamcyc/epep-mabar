for i, bots in pairs(getBots()) do
    if bots.name == getBot().name then
        indexBot = i
    end
    indexLast = i
end

bot = getBot()
bot.legit_mode = botAnimation
bot.auto_reconnect = delayReconnect
bot.move_range = botMoveRange
bot.move_interval = botMoveInterval
world = ""
doorFarm = ""
totalFarm = 0
worldListBot = {}
tree = {}

dividerSSeed = math.ceil(indexLast / #storageWorld)
worldSeed = storageWorld[math.ceil(indexBot / dividerSSeed)]

function place(id, tile_x, tile_y)
    return getBot():place(getLocal().posx // 32 + tile_x, getLocal().posy // 32 + tile_y, id)
end

function split(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t = {}
    for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
        table.insert(t, str)
    end
    return t
end

function isPlantable(tile)
    local tempTile = getTile(tile.x, tile.y + 1)
    if not tempTile.fg then
        return false
    end

    local collision = getInfo(tempTile.fg).collision_type
    return tempTile and (collision == 1 or collision == 2)
end

function reconnect()
    if getBot().status ~= BotStatus.online then
        while getBot().status ~= BotStatus.online do
            sleep(10000)
        end
        warp(_G.last_world, _G.last_door)
        find_path(_G.last_x, _G.last_y)
    end
end

function is_nuked()
    local console = getBot():getConsole()

    local function clearConsole()
        for i = 1, 50 do
            console:append("")
        end
    end
    for _, content in pairs(console.contents) do
        if content:find "That world is inaccessible." then
            clearConsole()
            return true
        end
    end

    return false
end

function warp(name, door)
    _G.last_world = name
    _G.last_door = door
    getBot():warp(name)
    local tries = 0
    while not getBot():isInWorld(name:upper()) do
        tries = tries + 1
        sleep(5000)
        if tries >= 6 and is_nuked() then
            return false
        else
            getBot():warp(name)
        end
    end

    if getBot():isInWorld(name:upper()) then
        getBot():warp(name, door)
        sleep(2000)
    end
    return true
end

function findItem(item_id)
    return getBot():getInventory():getItemCount(item_id)
end

function find_path(tile_x, tile_y)
    _G.last_x = tile_x
    _G.last_y = tile_y

    getBot():findPath(tile_x, tile_y)
    while not getBot():isInTile(tile_x, tile_y) do
        sleep(100)
        getBot():findPath(tile_x, tile_y)
    end
    return true
end

function plant()
    tree[_G.current_farm] = 0

    if modePlant == "UP" then
        start = 53
        ends = 0
        step = -1
    else
        start = 0
        ends = 53
        step = 1
    end


    plant1 = 1
    plant2 = 98
    plant3 = 1
    intiles = 0
    ismes = 2

    for height = start, ends, step do
        reconnect()
        for width = plant1, plant2, plant3 do
            reconnect()

            if findItem(itmSeed) == 0 or (spliceSeed and findItem(itmSeed2) ~= findItem(itmSeed)) or (useSpray and findItem(idSpray) ~= findItem(itmSeed2)) then
                takeItems(itmSeed)
                if spliceSeed and findItem(itmSeed2) ~= findItem(itmSeed) then
                    takeItems(itmSeed2)
                end
                if useSpray and findItem(idSpray) ~= findItem(itmSeed2) then
                    takeItems(idSpray)
                end
                warp(_G.current_farm, _G.current_door)
            end

            if getTile(width, height).fg == 0 and isPlantable(getTile(width, height)) and getBot():hasAccess(width + 1, plant) > 0 and findItem(itmSeed) > 0 and getLocal().posx // 32 == width and getLocal().posy // 32 == height and getBot():isInWorld(_G.current_farm:upper()) then
                if find_path(width, height) then
                    for i = 0, ismes, plant3 do
                        tree[_G.current_farm] = tree[_G.current_farm] + 1

                        while getTile(width + 1, height).fg == 0 and isPlantable(getTile(width + 1, height)) and getBot():hasAccess(width + 1, height) > 0 and findItem(itmSeed) > 0 and getLocal().posx // 32 == width and getLocal().posy // 32 == height and getBot():isInWorld(_G.current_farm:upper()) do
                            place(itmSeed, i, 0)
                            sleep(delayPlant)
                            reconnect()
                        end

                        if spliceSeed then
                            while getTile(width + 1, height).fg == itmSeed and findItem(itmSeed2) > 0 and getLocal().posx // 32 == width and getLocal().posy // 32 == height and getBot():isInWorld(_G.current_farm:upper()) and not getTile(width + 1, height):canHarvest() do
                                place(itmSeed2, i, 0)
                                sleep(delayPlant)
                                reconnect()
                            end
                        end

                        if useSpray then
                            while not getTile(width + 1, height):canHarvest() and findItem(idSpray) > 0 and getLocal().posx // 32 == width and getLocal().posy // 32 == height and getBot():isInWorld(_G.current_farm:upper()) do
                                place(idSpray, i, 0)
                                sleep(delayPlant)
                                reconnect()
                            end
                        end
                    end
                end
            end
        end

        if intiles == 1 then
            if plant1 == 98 then
                plant1 = 1
                plant2 = 98
                plant3 = 1
                ismes = 2
                intiles = 0
            elseif plant1 == 1 then
                plant1 = 98
                plant2 = 1
                plant3 = -1
                ismes = -2
                intiles = 0
            end
        else
            intiles = intiles + 1
        end
    end
end

function takeItems(item)
    if warp(worldSeed, doorStorage) then
        if item == itmSeed2 then
            count = findItem(itmSeed)
        elseif item == idSpray then
            count = findItem(itmSeed2)
        end

        for _, object in pairs(getObjects()) do
            if obj.id == item then
                find_path(round(obj.x / 32), math.floor(obj.y / 32))
                sleep(100)
                getBot():collectObject(obj.oid, 3)
                sleep(1000)
            end

            if item == itmSeed and findItem(item) > 0 then
                break
            elseif (item == itmSeed2 or item == idSpray) and findItem(item) >= count then
                break
            end
        end

        getBot():moveLeft(1)
        sleep(50)
        getBot():setDirection(false)
        sleep(100)

        if (item == itmSeed2 or item == idSpray) and findItem(item) > count then
            while findItem(item) > 0 do
                reconnect()
                getBot():findOutput()
                sleep(700)
                getBot():fastDrop(item, findItem(item) - count)
                sleep(300)
            end
        end
    else
        print(worldSeed .. " Nuked")
    end
end

function formatTime(seconds)
    if type(seconds) == "string" then
        return "..."
    end
    local hours = math.floor(seconds / 3600)
    local minutes = math.floor((seconds % 3600) / 60)
    local secs = seconds % 60

    if hours > 0 then
        return string.format("%d Hours %d Minutes %d Seconds", hours, minutes, secs)
    else
        return string.format("%d Minutes %d Seconds", minutes, secs)
    end
end

function goPlant()
    if not _G.nuked then
        sleep(100)
        startTime = os.time()
        plant()
        startTime = os.difftime(os.time(), startTime)
        waktu[_G.current_farm] = formatTime(startTime)
    else
        waktu[_G.current_farm] = "NUKED"
        tree[world] = "NUKED"

        _G.nuked = false
    end
end

for i = indexBot, 1, -1 do
    sleep(delayExe)
end

if farmPerBot > 0 then
    startData = (indexBot - 1) * farmPerBot + 1
    endData = startData + farmPerBot - 1
end

if farmPerBot == 0 then
    for _, plants in pairs(listWorld) do
        if plants then
            data = split(plants, ":")

            if #data == 2 then
                _G.current_farm = data[1]
                _G.current_door = data[2]

                if #worldListBot == 5 then
                    worldListBot = {}
                    waktu = {}
                    tree = {}
                end

                table.insert(worldListBot, _G.current_farm)
                _G.nuked = warp(_G.current_farm, _G.current_door)

                totalFarm = totalFarm + 1
                goPlant()
                append(resultFile .. getBot().index .. ".txt", plants .. "\n")
            else
                print(plants .. " Not Valid Format")
            end
        end
    end
else
    for datas = startData, endData do
        FarmList = listWorld[datas]
        if FarmList then
            data = split(FarmList, ":")

            if #data == 2 then
                _G.current_farm = data[1]
                _G.current_door = data[2]

                if #worldListBot == 5 then
                    worldListBot = {}
                    waktu = {}
                    tree = {}
                end

                table.insert(worldListBot, _G.current_farm)
                _G.nuked = warp(_G.current_farm, _G.current_door)

                totalFarm = totalFarm + 1
                goPlant()
                append(resultFile .. getBot().index .. ".txt", FarmList .. "\n")
            else
                print(FarmList .. " Not Valid Format")
            end
        end
    end
end
